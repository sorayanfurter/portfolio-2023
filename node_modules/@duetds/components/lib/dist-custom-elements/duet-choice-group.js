/*!
 * Built with Duet Design System
 */
import { p as proxyCustomElement, H, h, d as Host } from './p-fdc1ca33.js';
import { i as inheritGlobalTheme } from './p-4ebf1618.js';
import { f as findCheckedOption, w as watchForOptions } from './p-12721178.js';
import { d as defineCustomElement$6 } from './p-717d775c.js';
import { d as defineCustomElement$5 } from './p-a15eaed8.js';
import { d as defineCustomElement$4 } from './p-0674039c.js';
import { d as defineCustomElement$3 } from './p-d3213a33.js';
import { d as defineCustomElement$2 } from './p-1344c068.js';

const duetChoiceGroupCss = "*.sc-duet-choice-group,*.sc-duet-choice-group::after,*.sc-duet-choice-group::before{box-sizing:border-box;padding:0;margin:0;background:transparent;border:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}.sc-duet-choice-group-h{box-sizing:border-box;padding:0;margin:0;background:transparent;border:0;-moz-appearance:none;-webkit-appearance:none;appearance:none;display:block;width:100%}.horizontal.sc-duet-choice-group-h .duet-choice-group.sc-duet-choice-group{display:block;margin-bottom:-12px}.horizontal.sc-duet-choice-group-h .duet-choice-group.duet-no-stacking.sc-duet-choice-group{display:flex}@media (min-width: 48em){.horizontal.sc-duet-choice-group-h .duet-choice-group.sc-duet-choice-group{margin-bottom:0}}@media (max-width: 35.9375em){.horizontal.sc-duet-choice-group-h .duet-choice-group.sc-duet-choice-group{display:flex}}.horizontal.duet-choice-group-breakpoint-x-small.sc-duet-choice-group-h .duet-choice-group.sc-duet-choice-group:not(.duet-no-stacking){display:flex}@media (max-width: 22.5em){.horizontal.duet-choice-group-breakpoint-x-small.sc-duet-choice-group-h .duet-choice-group.sc-duet-choice-group:not(.duet-no-stacking){display:block}}.horizontal.duet-choice-group-breakpoint-small.sc-duet-choice-group-h .duet-choice-group.sc-duet-choice-group:not(.duet-no-stacking){display:block}@media (min-width: 36em){.horizontal.duet-choice-group-breakpoint-small.sc-duet-choice-group-h .duet-choice-group.sc-duet-choice-group:not(.duet-no-stacking){display:flex}}.horizontal.duet-choice-group-breakpoint-medium.sc-duet-choice-group-h .duet-choice-group.sc-duet-choice-group:not(.duet-no-stacking){display:block}@media (min-width: 48em){.horizontal.duet-choice-group-breakpoint-medium.sc-duet-choice-group-h .duet-choice-group.sc-duet-choice-group:not(.duet-no-stacking){display:flex}}.horizontal.duet-choice-group-breakpoint-large.sc-duet-choice-group-h .duet-choice-group.sc-duet-choice-group:not(.duet-no-stacking){display:block}@media (min-width: 62em){.horizontal.duet-choice-group-breakpoint-large.sc-duet-choice-group-h .duet-choice-group.sc-duet-choice-group:not(.duet-no-stacking){display:flex}}.horizontal.duet-choice-group-breakpoint-x-large.sc-duet-choice-group-h .duet-choice-group.sc-duet-choice-group:not(.duet-no-stacking){display:block}@media (min-width: 64.0625em){.horizontal.duet-choice-group-breakpoint-x-large.sc-duet-choice-group-h .duet-choice-group.sc-duet-choice-group:not(.duet-no-stacking){display:flex}}.duet-choice-group.sc-duet-choice-group{position:relative;width:100%;margin-bottom:-12px}";

const duetChoiceSelector = ":scope duet-choice:not(:scope duet-choice duet-choice-group duet-choice):not(:scope duet-choice duet-fieldset duet-choice)";
const DuetChoiceGroup$1 = /*@__PURE__*/ proxyCustomElement(class extends H {
  constructor() {
    super();
    this.__registerHost();
    this.choiceGroupName = "duet-choice-group";
    this.getChoices = () => {
      return Array.from(this.element.querySelectorAll(duetChoiceSelector));
    };
    this.isMyChoice = (choice) => {
      return this.getChoices().includes(choice);
    };
    /**
     * Component event handling.
     */
    this.onSelect = (ev) => {
      if (ev.detail.component !== "duet-choice") {
        return;
      }
      const selectedChoice = ev.target;
      if (selectedChoice && this.isMyChoice(selectedChoice)) {
        this.value = selectedChoice.value;
      }
      // Prevent events from bubbling up the DOM tree in case
      // this group is a sub-group of another choice group.
      ev.cancelBubble = true;
    };
    this.direction = "vertical";
    this.margin = "auto";
    this.theme = "";
    this.error = "";
    this.name = undefined;
    this.label = "Label";
    this.labelHidden = false;
    this.caption = undefined;
    this.tooltip = undefined;
    this.tooltipDirection = "auto";
    this.responsive = false;
    this.breakpoint = "small";
    this.value = undefined;
    this.disabled = undefined;
  }
  /**
   * Component lifecycle events.
   */
  async connectedCallback() {
    const el = this.element;
    if (this.value === undefined) {
      const choice = findCheckedOption(el, duetChoiceSelector);
      if (choice !== undefined) {
        await choice.componentOnReady();
        if (this.value === undefined) {
          this.value = choice.value;
        }
      }
    }
    this.mutationO = watchForOptions(el, duetChoiceSelector, newOption => {
      if (newOption !== undefined) {
        newOption.componentOnReady().then(() => {
          if (this.isMyChoice(newOption)) {
            this.value = newOption.value;
          }
        });
      }
      else {
        this.updateChoices();
      }
    });
    this.updateChoices();
  }
  disconnectedCallback() {
    if (this.mutationO) {
      this.mutationO.disconnect();
      this.mutationO = undefined;
    }
  }
  componentWillLoad() {
    inheritGlobalTheme(this);
  }
  /**
   * Local methods
   */
  async updateChoices() {
    /**
     * Make sure we get all choices first so values are up to date prior
     * to caching the choice group value
     */
    const choices = this.getChoices();
    const { value } = this;
    let hasChecked = false;
    // Walk the DOM in reverse order, since the last selected one wins
    for (const choice of choices) {
      choice.name = this.name;
      choice.groupDisabled = this.disabled;
      choice.groupDirection = this.direction;
      choice.groupResponsive = this.responsive;
      if (!hasChecked && choice.value === value) {
        // Correct value for this choice, but this choice isn't checked yet
        // and we haven't found a checked yet
        hasChecked = true;
        choice.checked = true;
      }
      else {
        // This choice doesn't have the correct value or the choice group has been already checked
        choice.checked = false;
      }
    }
    // Reset value if
    if (!hasChecked) {
      this.value = undefined;
    }
  }
  /**
   * render() function
   * Always the last one in the class.
   */
  render() {
    return (h(Host, { onDuetChange: this.onSelect, class: {
        horizontal: this.direction === "horizontal",
        "duet-choice-group-breakpoint-x-small": this.responsive && this.breakpoint === "x-small",
        "duet-choice-group-breakpoint-small": this.responsive && this.breakpoint === "small",
        "duet-choice-group-breakpoint-medium": this.responsive && this.breakpoint === "medium",
        "duet-choice-group-breakpoint-large": this.responsive && this.breakpoint === "large",
        "duet-choice-group-breakpoint-x-large": this.responsive && this.breakpoint === "x-large",
      } }, h("duet-fieldset", { label: this.label, labelHidden: this.labelHidden, caption: this.caption, error: this.error, margin: this.margin, theme: this.theme }, this.tooltip && (h("duet-tooltip", { slot: "tooltip", direction: this.tooltipDirection, accessibleInputLabel: this.label }, this.tooltip)), h("div", { class: { [this.choiceGroupName]: true, "duet-no-stacking": !this.responsive } }, h("slot", null)))));
  }
  get element() { return this; }
  static get watchers() { return {
    "value": ["updateChoices"],
    "disabled": ["updateChoices"],
    "name": ["updateChoices"],
    "direction": ["updateChoices"],
    "responsive": ["updateChoices"]
  }; }
  static get style() { return duetChoiceGroupCss; }
}, [6, "duet-choice-group", {
    "direction": [1],
    "margin": [1],
    "theme": [1025],
    "error": [1],
    "name": [1],
    "label": [1],
    "labelHidden": [4, "label-hidden"],
    "caption": [1],
    "tooltip": [1],
    "tooltipDirection": [1, "tooltip-direction"],
    "responsive": [4],
    "breakpoint": [1],
    "value": [1537],
    "disabled": [4]
  }]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["duet-choice-group", "duet-caption", "duet-fieldset", "duet-icon", "duet-tooltip", "duet-visually-hidden"];
  components.forEach(tagName => { switch (tagName) {
    case "duet-choice-group":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, DuetChoiceGroup$1);
      }
      break;
    case "duet-caption":
      if (!customElements.get(tagName)) {
        defineCustomElement$6();
      }
      break;
    case "duet-fieldset":
      if (!customElements.get(tagName)) {
        defineCustomElement$5();
      }
      break;
    case "duet-icon":
      if (!customElements.get(tagName)) {
        defineCustomElement$4();
      }
      break;
    case "duet-tooltip":
      if (!customElements.get(tagName)) {
        defineCustomElement$3();
      }
      break;
    case "duet-visually-hidden":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
  } });
}

const DuetChoiceGroup = DuetChoiceGroup$1;
const defineCustomElement = defineCustomElement$1;

export { DuetChoiceGroup, defineCustomElement };
