/*!
 * Built with Duet Design System
 */
const watchFor = (containerEl, tagName, onChange, changeHandler, options = {
  childList: true,
  subtree: true,
}) => {
  let mutation;
  if (typeof MutationObserver !== "undefined") {
    mutation = new MutationObserver(mutationList => {
      onChange(changeHandler(mutationList, tagName));
    });
    mutation.observe(containerEl, options);
  }
  return mutation;
};
export const watchForOptions = (containerEl, tagName, onChange) => {
  return watchFor(containerEl, tagName, onChange, getSelectedOption);
};
export const watchForElement = (containerEl, tagName, onChange) => {
  return watchFor(containerEl, tagName, onChange, getElementItem, {
    childList: true,
    subtree: true,
  });
};
const getElementItem = (mutationList) => {
  let addedNode = false;
  let removedNode = false;
  mutationList.forEach(mut => {
    if (mut.addedNodes.length) {
      addedNode = true;
    }
    if (mut.removedNodes.length) {
      removedNode = true;
    }
  });
  return { addedNode, removedNode, mutationList };
};
const getSelectedOption = (mutationList, tagName) => {
  let newOption;
  mutationList.forEach(mut => {
    // tslint:disable-next-line: prefer-for-of
    for (let i = 0; i < mut.addedNodes.length; i++) {
      newOption = findCheckedOption(mut.addedNodes[i], tagName) || newOption;
    }
  });
  return newOption;
};
export const findCheckedOption = (el, tagName) => {
  if (el.nodeType !== 1) {
    return undefined;
  }
  const options = el.tagName === tagName.toUpperCase() ? [el] : Array.from(el.querySelectorAll(tagName));
  return options.find((o) => o.checked === true);
};
export const findErrorItems = (el, tagName) => {
  if (el.nodeType !== 1) {
    return undefined;
  }
  const options = el.tagName === tagName.toUpperCase() ? [el] : Array.from(el.querySelectorAll(tagName));
  return options.find((o) => o.checked === true);
};
