/*!
 * Built with Duet Design System
 */
import * as tokens from "@duetds/tokens";
const allowedThemes = ["turva"];
const MATCH_CAPITAL_CASE = /[A-Z]/g;
export function isCamelCase(str) {
  const camel = MATCH_CAPITAL_CASE.test(str);
  const barredString = !str.includes("_") && !str.includes("-") && !str.includes(" ");
  return camel && barredString;
}
export function isDashCase(str) {
  const dash = str.includes("-");
  const barredString = str.includes(" ") || str.includes("_");
  const barredStartingString = str.charAt(0) === "-";
  return dash && !barredString && !barredStartingString;
}
export function capitalize(str = "") {
  return `${str.charAt(0).toUpperCase()}${str.slice(1)}`;
}
function lowerCaseFirst(str = "") {
  return `${str.charAt(0).toLowerCase()}${str.slice(1)}`;
}
export function camelize(str = "") {
  const arr = str.split("-");
  //loop through each element of the array and capitalize the first letter.'
  arr.forEach((string, index) => {
    arr[index] = capitalize(string);
  });
  return arr.join("");
}
export function getTheme(theme = "") {
  if (allowedThemes.includes(theme.toLowerCase())) {
    return theme.toLowerCase();
  }
  return "";
}
export function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function hasType(t, str = "") {
  return str.indexOf(capitalizeFirstLetter(t)) === 0 || str.indexOf(t) === 0;
}
function addPrefix(prefix, str = "") {
  if (str && !isDashCase(str) && !hasType(prefix, str)) {
    return `${prefix}${capitalize(str)}`;
  }
  return str;
}
function addTheme(str, theme) {
  const hasTheme = getTheme(theme).length;
  if (hasTheme && str.indexOf(theme) === -1) {
    return `${str}${capitalize(theme)}`;
  }
  return str;
}
export function getColorByName(name, theme = "") {
  if (!name) {
    return undefined;
  }
  const defaultColor = convertToColorName(name);
  const themedColor = convertToColorName(name, theme);
  // lets just try to get the color first to save some cycles
  let resolvedToken = tokens[themedColor];
  if (!resolvedToken) {
    resolvedToken = tokens[defaultColor];
  }
  return resolvedToken;
}
export function convertToColorName(name = "", theme = "") {
  let colorResolution = name;
  const dash = isDashCase(name);
  if (dash) {
    colorResolution = camelize(colorResolution);
  }
  colorResolution = addPrefix("color", colorResolution);
  colorResolution = addTheme(colorResolution, theme);
  // takes care of the case where colorPrimaryDark ends up with ColorPrimaryDark
  colorResolution = lowerCaseFirst(colorResolution);
  return colorResolution;
}
function getTokenByName(prefix, name) {
  if (!name) {
    return undefined;
  }
  let tokenResolution = name;
  const dash = isDashCase(name);
  if (dash) {
    tokenResolution = camelize(tokenResolution);
  }
  tokenResolution = addPrefix(prefix, tokenResolution);
  tokenResolution = lowerCaseFirst(tokenResolution);
  try {
    return tokens[tokenResolution];
  }
  catch (e) {
    return undefined;
  }
}
export function getFontSizeByName(name) {
  return getTokenByName("fontSize", name);
}
export function getFontWeightByName(name) {
  return getTokenByName("fontWeight", name);
}
export function rgbaColorFromRgb(color, opacity) {
  if (!color || (opacity !== 0 && !opacity)) {
    return undefined;
  }
  const f = color.split(",");
  const R = parseInt(f[0].slice(4)), G = parseInt(f[1]), B = parseInt(f[2]);
  return `rgba(${R},${G},${B},${opacity})`;
}
export function shadeRGBColor(color, percent) {
  const f = color.split(","), t = percent < 0 ? 0 : 255, p = percent < 0 ? percent * -1 : percent;
  let R = parseInt(f[0].slice(4)), G = parseInt(f[1]), B = parseInt(f[2]);
  R = Math.round((t - R) * p) + R;
  G = Math.round((t - G) * p) + G;
  B = Math.round((t - B) * p) + B;
  R = R < 0 ? 0 : R;
  R = R > 255 ? 255 : R;
  G = G < 0 ? 0 : G;
  G = G > 255 ? 255 : G;
  B = B < 0 ? 0 : B;
  B = B > 255 ? 255 : B;
  return `rgb(${R},${G},${B})`;
}
// remove wrapping speech marks.
// media query tokens are wrapped in speech marks,
// which need to be removed before use with matchMedia.
const unwrap = (str) => str.substring(1, str.length - 1);
export const breakpointToToken = {
  "xxx-small": unwrap(tokens.mediaQueryXxxSmall),
  "xx-small": unwrap(tokens.mediaQueryXxSmall),
  "x-small": unwrap(tokens.mediaQueryXSmall),
  small: unwrap(tokens.mediaQuerySmall),
  medium: unwrap(tokens.mediaQueryMedium),
  large: unwrap(tokens.mediaQueryLarge),
  "x-large": unwrap(tokens.mediaQueryXLarge),
  "xx-large": unwrap(tokens.mediaQueryXxLarge),
  "xxx-large": unwrap(tokens.mediaQueryXxxLarge),
};
export const breakpointTokensUpTo = Object.keys(breakpointToToken).filter(key => key.indexOf("x-small") !== -1);
export const breakpointTokensFrom = Object.keys(breakpointToToken).filter(key => !breakpointTokensUpTo.includes(key));
