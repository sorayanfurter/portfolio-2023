/*!
 * Built with Duet Design System
 */
/**
 *  function that takes a string value or number and looks for any character resembling a minus,
 *  it will then replace it with a hypen-minus and return the parseFloat value of that string
 *  it will string / number cast the value to a number and return that number
 *  known issues: if a negative number is indicated with other characters than a "minus like" character, it will throw
 *  - an example is that some locales use (number) as an indicator for negative values instead of -number
 */
export function SafeParseFloat(value, locale) {
  let results;
  if (typeof value === "string") {
    //the minuses are NOT the same characters, they differ in unicode for some languages
    // "‐", "−", "–", and "—"
    let convertedMinus = value.replace("−", "-").replace("‐", "-").replace("−", "-").replace("–", "-").replace("—", "-");
    if (locale) {
      convertedMinus = ConvertToEnUS(convertedMinus, locale, false);
    }
    // replace all possible spaces from the string
    convertedMinus = convertedMinus.replace(/\s+/g, "");
    convertedMinus = convertedMinus.replace(/(?!^-?\d*\.{0,1}\d+$)/g, "");
    /*
    example: https://regex101.com/r/np7FqS/1
      /(?!^-?\d*\.{0,1}\d+$)/g
      Negative Lookahead (?!^-?\d*\.{0,1}\d+$)
      Assert that the Regex below does not match
      ^ asserts position at start of a line
      - matches the character - with index 4510 (2D16 or 558) literally (case sensitive)
      ? matches the previous token between zero and one times, as many times as possible, giving back as needed (greedy)
      \d matches a digit (equivalent to [0-9])
      * matches the previous token between zero and unlimited times, as many times as possible, giving back as needed (greedy)
      \. matches the character . with index 4610 (2E16 or 568) literally (case sensitive)
      {0,1} matches the previous token between zero and one times, as many times as possible, giving back as needed (greedy)
      \d matches a digit (equivalent to [0-9])
      + matches the previous token between one and unlimited times, as many times as possible, giving back as needed (greedy)
      $ asserts position at the end of a line
      Global pattern flags
      g modifier: global. All matches (don't return after first match)
      m modifier: multi line. Causes ^ and $ to match the begin/end of each line (not only begin/end of string)
    */
    results = parseFloat(convertedMinus);
  }
  if (typeof value === "number") {
    results = parseFloat(String(value));
  }
  if (!isNaN(Number(results))) {
    return Number(results);
  }
  if (value === null || value === undefined) {
    return null;
  }
  throw new Error("Invalid value passed to SafeParseFloat");
}
// string conversion function that takes a locale and coverts decimal indicator to en-US indicator
// and takes the thousand separator for the given locale and transforms that to the en-US separator
export function ConvertToEnUS(value, locale, replaceThousands = false) {
  let replacedValue;
  const localeSeparator = new Intl.NumberFormat(locale).format(1 / 2).replace(/[0-9]/g, "");
  const enUSSeparator = new Intl.NumberFormat("en-US").format(1 / 2).replace(/[0-9]/g, "");
  const thousandSeparator = new Intl.NumberFormat(locale).format(1000).replace(/[0-9]/g, "");
  const enUSThousandSeparator = new Intl.NumberFormat("en-US").format(1000).replace(/[0-9]/g, "");
  // double conversions to avoid ,->. and .->, at the same time resulting in a double conversion
  replacedValue = value.replace(localeSeparator, "DECIMALSEPARATOR");
  if (replaceThousands) {
    replacedValue = replacedValue.replace(thousandSeparator, "THOUSANDSEPARATOR");
  }
  else {
    replacedValue = replacedValue.replace(thousandSeparator, "");
  }
  replacedValue = replacedValue.replace("DECIMALSEPARATOR", enUSSeparator);
  replacedValue = replacedValue.replace("THOUSANDSEPARATOR", enUSThousandSeparator);
  return replacedValue;
}
export const roundTo = (val, multiple) => Math.round(val / multiple) * multiple;
export const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
