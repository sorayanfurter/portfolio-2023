/*!
 * Built with Duet Design System
 */
import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-b45ea754.js';
import { i as inheritGlobalTheme } from './themeable-component-cb76be7c.js';
import { c as createID } from './create-id-981107da.js';
import { a as isArrowRightKey, b as isArrowUpKey, c as isArrowDownKey, d as isArrowLeftKey, e as isBackspaceKey } from './keyboard-utils-d237bd5a.js';
import { g as getLanguage, b as getLocale, a as getLocaleString } from './language-utils-6be16ff0.js';
import './string-utils-5954f458.js';

var actionAdd={"title":"action-add","tags":"action add plus","svg":"<svg fill=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\" role=\"img\"><path d=\"M12 24a.75.75 0 0 1-.75-.75v-10.5H.75a.75.75 0 0 1 0-1.5h10.5V.75a.75.75 0 0 1 1.5 0v10.5h10.5a.75.75 0 0 1 0 1.5h-10.5v10.5A.75.75 0 0 1 12 24z\"/></svg>"};

var actionSubtract={"title":"action-subtract","tags":"action subtract minus remove delete cancel","svg":"<svg fill=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\" role=\"img\"><path d=\"M.75 12.788a.75.75 0 0 1 0-1.5h22.5a.75.75 0 0 1 0 1.5z\"/></svg>"};

/**
 *  function that takes a string value or number and looks for any character resembling a minus,
 *  it will then replace it with a hypen-minus and return the parseFloat value of that string
 *  it will string / number cast the value to a number and return that number
 *  known issues: if a negative number is indicated with other characters than a "minus like" character, it will throw
 *  - an example is that some locales use (number) as an indicator for negative values instead of -number
 */
function SafeParseFloat(value, locale) {
  let results;
  if (typeof value === "string") {
    //the minuses are NOT the same characters, they differ in unicode for some languages
    // "‐", "−", "–", and "—"
    let convertedMinus = value.replace("−", "-").replace("‐", "-").replace("−", "-").replace("–", "-").replace("—", "-");
    if (locale) {
      convertedMinus = ConvertToEnUS(convertedMinus, locale, false);
    }
    // replace all possible spaces from the string
    convertedMinus = convertedMinus.replace(/\s+/g, "");
    convertedMinus = convertedMinus.replace(/(?!^-?\d*\.{0,1}\d+$)/g, "");
    /*
    example: https://regex101.com/r/np7FqS/1
      /(?!^-?\d*\.{0,1}\d+$)/g
      Negative Lookahead (?!^-?\d*\.{0,1}\d+$)
      Assert that the Regex below does not match
      ^ asserts position at start of a line
      - matches the character - with index 4510 (2D16 or 558) literally (case sensitive)
      ? matches the previous token between zero and one times, as many times as possible, giving back as needed (greedy)
      \d matches a digit (equivalent to [0-9])
      * matches the previous token between zero and unlimited times, as many times as possible, giving back as needed (greedy)
      \. matches the character . with index 4610 (2E16 or 568) literally (case sensitive)
      {0,1} matches the previous token between zero and one times, as many times as possible, giving back as needed (greedy)
      \d matches a digit (equivalent to [0-9])
      + matches the previous token between one and unlimited times, as many times as possible, giving back as needed (greedy)
      $ asserts position at the end of a line
      Global pattern flags
      g modifier: global. All matches (don't return after first match)
      m modifier: multi line. Causes ^ and $ to match the begin/end of each line (not only begin/end of string)
    */
    results = parseFloat(convertedMinus);
  }
  if (typeof value === "number") {
    results = parseFloat(String(value));
  }
  if (!isNaN(Number(results))) {
    return Number(results);
  }
  if (value === null || value === undefined) {
    return null;
  }
  throw new Error("Invalid value passed to SafeParseFloat");
}
// string conversion function that takes a locale and coverts decimal indicator to en-US indicator
// and takes the thousand separator for the given locale and transforms that to the en-US separator
function ConvertToEnUS(value, locale, replaceThousands = false) {
  let replacedValue;
  const localeSeparator = new Intl.NumberFormat(locale).format(1 / 2).replace(/[0-9]/g, "");
  const enUSSeparator = new Intl.NumberFormat("en-US").format(1 / 2).replace(/[0-9]/g, "");
  const thousandSeparator = new Intl.NumberFormat(locale).format(1000).replace(/[0-9]/g, "");
  const enUSThousandSeparator = new Intl.NumberFormat("en-US").format(1000).replace(/[0-9]/g, "");
  // double conversions to avoid ,->. and .->, at the same time resulting in a double conversion
  replacedValue = value.replace(localeSeparator, "DECIMALSEPARATOR");
  if (replaceThousands) {
    replacedValue = replacedValue.replace(thousandSeparator, "THOUSANDSEPARATOR");
  }
  else {
    replacedValue = replacedValue.replace(thousandSeparator, "");
  }
  replacedValue = replacedValue.replace("DECIMALSEPARATOR", enUSSeparator);
  replacedValue = replacedValue.replace("THOUSANDSEPARATOR", enUSThousandSeparator);
  return replacedValue;
}
const roundTo = (val, multiple) => Math.round(val / multiple) * multiple;
const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

const duetNumberInputCss = "*.sc-duet-number-input,*.sc-duet-number-input::after,*.sc-duet-number-input::before{box-sizing:border-box;padding:0;margin:0;background:transparent;border:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}.sc-duet-number-input-h{box-sizing:border-box;padding:0;margin:0;background:transparent;border:0;-moz-appearance:none;-webkit-appearance:none;appearance:none;margin-right:16px !important;margin-bottom:12px !important;display:inline-flex;width:100%;min-width:calc(33.333% - 8px);max-width:100%;line-height:1.25;text-align:left;vertical-align:bottom}.sc-duet-number-input-h:last-child,.sc-duet-number-input-h:last-of-type{margin-right:0 !important}@media (min-width: 36em){.sc-duet-number-input-h{width:calc(50% - 16px - 3px)}}.duet-expand.sc-duet-number-input-h{width:100% !important}.duet-m-0.sc-duet-number-input-h{margin:0 !important}.duet-number-container.sc-duet-number-input{position:relative;width:100%}.duet-number-buttons.sc-duet-number-input{-webkit-user-select:none;user-select:none;position:absolute;top:1px;right:1px;z-index:200;width:96px;height:calc(100% - 2px)}.duet-number-buttons.sc-duet-number-input .duet-number-button.sc-duet-number-input{position:relative;display:inline-flex;align-items:center;justify-content:center;width:50%;height:100%;text-align:center;cursor:pointer;background:transparent;-webkit-appearance:none;appearance:none}.duet-number-buttons.sc-duet-number-input .duet-number-button[aria-disabled=true].sc-duet-number-input,.duet-number-buttons.sc-duet-number-input .duet-number-button.sc-duet-number-input:disabled{pointer-events:none}.duet-number-buttons.sc-duet-number-input .duet-number-button[aria-disabled=true].sc-duet-number-input duet-icon.sc-duet-number-input,.duet-number-buttons.sc-duet-number-input .duet-number-button.sc-duet-number-input:disabled duet-icon.sc-duet-number-input{opacity:0.4}.duet-number-buttons.sc-duet-number-input .duet-number-button.sc-duet-number-input:active duet-icon.sc-duet-number-input{transform:translateY(1px)}.duet-number-buttons.sc-duet-number-input .duet-number-button.sc-duet-number-input:focus{outline:0}.user-is-tabbing.sc-duet-number-input-h .duet-number-buttons.sc-duet-number-input .duet-number-button.sc-duet-number-input:focus{z-index:2;box-shadow:0 0 0 2px rgb(0, 119, 179)}.duet-theme-turva .user-is-tabbing.sc-duet-number-input-h .duet-number-buttons.sc-duet-number-input .duet-number-button.sc-duet-number-input:focus{box-shadow:0 0 0 2px rgb(23, 28, 58)}.duet-number-buttons.sc-duet-number-input .duet-number-button.sc-duet-number-input:first-of-type{border-left:1px solid rgb(207, 210, 212)}.duet-number-buttons.sc-duet-number-input .duet-number-button.sc-duet-number-input:first-of-type::before{position:absolute;top:0;left:-6px;width:6px;height:100%;content:\"\";background:linear-gradient(to left, rgba(207, 210, 212, 0.2) 0%, rgba(207, 210, 212, 0.2) 1px, rgba(207, 210, 212, 0.1) 1px, rgba(207, 210, 212, 0) 100%)}.duet-number-buttons.sc-duet-number-input .duet-number-button.sc-duet-number-input:last-of-type{border-top-right-radius:4px;border-bottom-right-radius:4px}.duet-number-buttons.sc-duet-number-input .duet-number-button.sc-duet-number-input:last-of-type::before{position:absolute;top:20%;left:0;width:1px;height:60%;content:\"\";background:rgb(225, 227, 230)}.duet-theme-turva.sc-duet-number-input-h .duet-number-buttons.sc-duet-number-input .duet-number-button.sc-duet-number-input:first-of-type::before{background:linear-gradient(to left, rgba(207, 207, 209, 0.2) 0%, rgba(207, 207, 209, 0.2) 1px, rgba(207, 207, 209, 0.1) 1px, rgba(207, 207, 209, 0) 100%)}.duet-theme-turva.sc-duet-number-input-h .duet-number-buttons.sc-duet-number-input .duet-number-button.sc-duet-number-input:last-of-type::before{background:rgb(228, 228, 230)}";

const DuetNumberInput = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.duetChange = createEvent(this, "duetChange", 3);
    this.duetInput = createEvent(this, "duetInput", 3);
    this.duetBlur = createEvent(this, "duetBlur", 7);
    this.duetFocus = createEvent(this, "duetFocus", 7);
    this.inputId = createID("DuetInput");
    /**
     * Component event handling.
     */
    this.handleFocus = () => {
      // This state is saved on focus so we can compare on blur to it.
      this.focusedValue = this.value;
    };
    this.handleKeyDown = (ev) => {
      if (isArrowRightKey(ev) || isArrowUpKey(ev)) {
        this.add(ev);
      }
      else if (isArrowDownKey(ev) || isArrowLeftKey(ev)) {
        this.subtract(ev);
      }
      else if (isBackspaceKey(ev)) {
        this.clearValue();
      }
    };
    this.handleChange = (ev) => {
      const input = ev.target;
      if (input && input.value) {
        try {
          let value = SafeParseFloat(input.value, this.locale);
          // Make sure that everything works if the user clears the input and
          // starts typing non-numeric characters.
          if (isNaN(value) || value == null) {
            value = this.min || 0;
          }
          this.setValue(value);
          this.duetInput.emit({
            component: "duet-number-input",
            originalEvent: ev,
            value: SafeParseFloat(this.value, this.locale).toString(),
            valueAsNumber: value,
          });
        }
        catch (e) {
          this.duetInput.emit({
            component: "duet-number-input",
            originalEvent: ev,
            value: null,
            valueAsNumber: null,
          });
        }
      }
      else {
        this.duetInput.emit({
          component: "duet-number-input",
          originalEvent: ev,
          value: null,
          valueAsNumber: null,
        });
      }
    };
    this.handleBlur = (ev) => {
      const input = ev.target;
      if (!input) {
        return;
      }
      if (input.value) {
        // On blur we want to make sure that the user input is between the min and max values,
        // and also round it up or down to the nearest step.
        try {
          let value = SafeParseFloat(input.value, this.locale);
          if (this.rounding) {
            value = roundTo(value, this.step);
          }
          value = clamp(value, this.min, this.max);
          if (value !== SafeParseFloat(this.value, this.locale) ||
            value !== SafeParseFloat(this.focusedValue, this.locale)) {
            this.setValue(value);
            this.emitChange(ev);
          }
        }
        catch (e) {
          this.emitNull(ev);
        }
      }
      else {
        this.emitNull(ev);
      }
    };
    /**
     * Local methods.
     */
    this.emitChange = (ev) => {
      const currentValue = SafeParseFloat(this.value, this.locale);
      this.duetChange.emit({
        originalEvent: ev,
        value: currentValue.toString(),
        valueAsNumber: currentValue,
        component: "duet-number-input",
      });
    };
    this.emitNull = (ev) => {
      this.duetChange.emit({
        originalEvent: ev,
        value: null,
        valueAsNumber: null,
        component: "duet-number-input",
      });
    };
    this.localizeValue = (value) => {
      // Returns a localized string that can be used as input value.
      return value.toLocaleString(this.locale);
    };
    this.setValue = (value) => {
      // Set the localized prop value.
      this.value = this.localizeValue(value);
      // Finally also set the visible input value and unit.
      this.duetInputElement.value = `${this.value} ${this.unit}`;
    };
    this.add = (ev) => {
      // If this was called via a html button, prevent the default functionality
      // to not trigger submit accidentally when used inside a form.
      if (ev) {
        ev.preventDefault();
      }
      const cleanedValue = SafeParseFloat(this.value, this.locale);
      // Only fire change event when necessary
      if (cleanedValue === this.max) {
        return;
      }
      // in cases where no value set, incrementing should go to min
      let newValue = cleanedValue == null ? this.min : cleanedValue + this.step;
      // handle cases where value is not multiple of step
      // e.g. if someone enters 199, with a step of 100, add should go to 200
      // and if someone enters 101, add should also go to 200
      if (newValue % this.step !== 0) {
        const adjustment = newValue % this.step;
        newValue -= adjustment;
      }
      const clampedValue = clamp(newValue, this.min, this.max);
      this.value = this.localizeValue(clampedValue);
      this.emitChange(ev);
    };
    this.subtract = (ev) => {
      // If this was called via a html button, prevent the default functionality
      // to not trigger submit accidentally when used inside a form.
      if (ev) {
        ev.preventDefault();
      }
      const currentValue = SafeParseFloat(this.value, this.locale);
      // Only fire change event when necessary.
      if (currentValue === this.min) {
        return;
      }
      let newValue = currentValue - this.step;
      // handle cases where value is not multiple of step
      // if someone enters 199, with a step of 100, subtract should go to 100
      // and if someone enters 101, subtract should also go to 100
      if (newValue % this.step !== 0) {
        const adjustment = this.step - (newValue % this.step);
        newValue += adjustment;
      }
      newValue = clamp(newValue, this.min, this.max);
      this.value = this.localizeValue(newValue);
      this.emitChange(ev);
    };
    this.language = getLanguage();
    this.locale = getLocale(this.language).locale;
    this.unit = getLocale(this.language).money;
    this.focusedValue = undefined;
    this.accessibleActiveDescendant = undefined;
    this.accessibleControls = undefined;
    this.accessibleDetails = undefined;
    this.accessibleLabelledBy = undefined;
    this.accessibleDescription = undefined;
    this.accessibleOwns = undefined;
    this.accessibleDescribedBy = undefined;
    this.accessibleLiveDefaults = {
      fi: "{current} euroa valittuna",
      en: "{current} euros selected",
      sv: "{current} euro valt",
    };
    this.accessibleLive = getLocaleString(this.accessibleLiveDefaults, this.language);
    this.accessibleLiveEnabled = true;
    this.accessibleAddDefaults = {
      fi: "Lisää summaan",
      en: "Add to the amount",
      sv: "Lägg till beloppet",
    };
    this.accessibleAdd = getLocaleString(this.accessibleAddDefaults, this.language);
    this.accessibleSubtractDefaults = {
      fi: "Vähennä summasta",
      en: "Subtract from the amount",
      sv: "Dra från beloppet",
    };
    this.accessibleSubtract = getLocaleString(this.accessibleSubtractDefaults, this.language);
    this.theme = "";
    this.margin = "auto";
    this.expand = false;
    this.identifier = undefined;
    this.min = 0;
    this.labelDefaults = {
      fi: "Nimilappu",
      en: "Label",
      sv: "Etikett",
    };
    this.label = getLocaleString(this.labelDefaults, this.language);
    this.labelHidden = false;
    this.max = 1000000;
    this.name = undefined;
    this.error = "";
    this.tooltip = "";
    this.step = 5000;
    this.rounding = true;
    this.role = undefined;
    this.disabled = false;
    this.required = false;
    this.value = undefined;
  }
  /**
   * Component lifecycle events.
   */
  componentWillLoad() {
    inheritGlobalTheme(this);
    // Format the number value to a localeString initially.
    if (this.value) {
      this.value = this.localizeValue(SafeParseFloat(this.value, this.locale));
    }
  }
  /**
   * Sets focus on the specified `duet-number-input`. Use this method instead of the global
   * `input.focus()`.
   */
  async setFocus(options) {
    this.duetInputElement.setFocus(options);
  }
  clearValue() {
    this.value = null;
    this.duetInputElement.value = "";
  }
  formatAnnouncement() {
    const current = !!this.value ? SafeParseFloat(this.value, this.locale) : null;
    if (current == null) {
      return "";
    }
    return this.accessibleLive.replace("{current}", current.toString(10));
  }
  /**
   * render() function
   * Always the last one in the class.
   */
  render() {
    const identifier = this.identifier || this.inputId;
    const maxlength = `${this.localizeValue(this.max)} ${this.unit}`.length;
    const cleanedValue = !!this.value ? SafeParseFloat(this.value, this.locale) : null;
    return (h(Host, { class: {
        "duet-theme-turva": this.theme === "turva",
        "duet-expand": this.expand,
        "duet-m-0": this.margin === "none",
      } }, h("div", { class: "duet-number-container" }, h("duet-input", { ref: input => (this.duetInputElement = input), onDuetChange: event => this.handleChange(event), onDuetFocus: this.handleFocus, onDuetBlur: event => this.handleBlur(event), onKeyDown: event => this.handleKeyDown(event), label: this.label, value: this.value ? `${this.value} ${this.unit}` : "", error: this.error, "aria-valuemin": this.min, "aria-valuemax": this.max, "aria-valuenow": cleanedValue != null ? cleanedValue : "", maxlength: maxlength, name: this.name, component: "number", required: this.required, disabled: this.disabled, role: this.role, labelHidden: this.labelHidden, tooltip: this.tooltip, identifier: identifier, theme: this.theme, margin: "none", expand: true, numericKeyboard: true, autoComplete: "off", type: "text", accessibleActiveDescendant: this.accessibleActiveDescendant, accessibleLabelledBy: this.accessibleLabelledBy, accessibleDescription: this.accessibleDescription, accessibleDetails: this.accessibleDetails, accessibleControls: this.accessibleControls, accessibleOwns: this.accessibleOwns, accessibleDescribedBy: this.accessibleDescribedBy }, h("div", { class: { "duet-number-buttons": true, "duet-no-label": this.labelHidden } }, h("button", { "aria-controls": identifier, disabled: this.disabled, "aria-disabled": cleanedValue == null || cleanedValue === this.min ? "true" : "false", class: "duet-number-button duet-number-button-subtract", onClick: this.subtract, type: "button" }, h("duet-visually-hidden", null, this.accessibleSubtract, " ", this.step), h("duet-icon", { icon: actionSubtract.svg, size: "small", margin: "none", color: this.theme === "turva" ? "secondary-turva" : "secondary" })), h("button", { "aria-controls": identifier, disabled: this.disabled, "aria-disabled": cleanedValue === this.max ? "true" : "false", class: "duet-number-button duet-number-button-add", onClick: this.add, type: "button" }, h("duet-visually-hidden", null, this.accessibleAdd, " ", this.step), h("duet-icon", { icon: actionAdd.svg, size: "small", margin: "none", color: this.theme === "turva" ? "secondary-turva" : "secondary" })))), this.accessibleLiveEnabled && (h("duet-visually-hidden", { "aria-live": "polite", "aria-atomic": "true", "aria-relevant": "all" }, this.formatAnnouncement())))));
  }
  get element() { return getElement(this); }
};
DuetNumberInput.style = duetNumberInputCss;

export { DuetNumberInput as duet_number_input };
